# Two Pointer Algorithm (투포인터 알고리즘)
* 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘

## 문제 예시
### 특정한 합을 가지는 부분 연속 수열 찾기
1. 시작점과 끝점이 첫번쨰 원소의 인덱스를 가리키도록 한다.
2. 현재 부분 합이 M과 같다면 카운트한다.
3. 현재 부분 합이 M보다 작다면 end를 1 증가시킨다.
4. 현재 부분 합이 M보다 크거나 같다면 start를 1 증가시킨다.
5. 모든 경우를 확인할 때까지 2-4번 과정을 반복한다.

### 백준 문제 22945번
```python3
import sys
input = sys.stdin.readline

N = int(input())
#개발자 2명 사이에 존재하는 다른 개발자 수와 최소 개발자 능력치
#능력치 최대값!
lst = list(map(int, input().split()))

start, end = 0, len(lst)-1
res = 0
while start <= end:
    x = min(lst[start], lst[end])
    res = max(x*(end-start-1),res)
    if lst[start] == x:
        start += 1
    else:
        end -= 1

print(res)
```
* 최대 개발자의 능력치를 찾는 것으로, 두 능력자 사이의 개발자 수 * 두 능력자 중 가장 작은 능력치가 가장 큰 값을 찾는 문제이다.
* 처음엔 순서대로 고려하는 것으로 생각해서 DP를 고려하였으나, 특정한 규칙이 없음을 깨닫고 다른 방법을 사용해보기로 결정하였다.
* 투포인터 알고리즘은 문제의 요점과 그에 대한 규칙만 제대로 파악한다면 매우 적은 시간복잡도로 해결할 수 있지만, 이를 명확하게 떠올리는 데에 어려움을 겪었다.
* 그래서 그냥 start 능력 값이 더 작은 값이면 start 인덱스를 증가시키고, 아니라면 end 값을 1감소시켜주었는데 정답이었다.
* 다시 복기해보니 앞서 소개한 예시 문제와 비슷한 논리를 가지고 있었다.
* 최솟값을 더 높이기 위한 시도를 해야하기 때문에, 최소값 인덱스를 바꿔줘야 했다.
* 이러한 문제는 바로 투포인터 알고리즘을 적용하는지 바로 파악할 수 없기 때문에, 비슷한 문제를 많이 풀어봐야할 것 같다.
